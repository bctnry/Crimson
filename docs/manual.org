#+TITLE: Crimson User Manual
#+AUTHOR: Zaaktin Lam

* Introduction

Crimson is a lexer generator and parser generator combined, where:

+ The lexer generator part is basically done and probably won't change much in the future;
+ The parser generator part haven't started yet (but I'm currently thinking about how to approach this)

* The lexer generator

** How it works

The core idea goes as follow:

+ The *lexical* syntax of most programming languages can be represented using a regular language, and can thus be accepted by a non-deterministic automaton and expressed using a single regular expression.
+ Vanilla regular expressions (i.e. the ones without any extra semantics like look-ahead and look-behind) can be "compiled" into a program for a special kind of virtual machine. This approach [[https://swtch.com/~rsc/regexp/regexp2.html][is brilliantly explained by Russ Cox in one of his articles]].
+ The lexical syntax of the intended language is expressed by a list of regular expressions since in most (if not all) cases the regular language that accepts the syntax can be treated as a composition of multiple "smaller" languages each matches a singular kind of token. The "master" regular expression is then trivially generated by combining together from these smaller pieces and feed through the regular expression compiler, generating a program for the virtual machine; this program is then bundled with the implementation of the virtual machine to form the final generated lexer.

** Syntax, features & behaviours

#+BEGIN_SRC
# Program ::= TokenDecl*
# TokenDecl ::= "~"? NAME "=" "/" Regex "/" RetainingClause?
# NAME = /[a-zA-Z_][0-9a-zA-Z_]*/
# AtomicRegex ::= CharOrNormalEsc
#               | In
#               | NotIn
#               | "(?:" Regex ("|" Regex)* ")"
#               | "{" NAME "}"
# RegexSegment ::= AtomicRegex ("?" | "*" | "+" | "??" | "*?" | "+?")?
# RetainingClause ::= "{" NUMBER (":" NAME)? "}"
# Regex ::= RegexSegment+
# In ::= "[" (Range|CharOrInEsc) "]"
# NotIn ::= "[^" (Range|CharOrInEsc) "]"
# Range ::= CHAR "-" CHAR
# CharOrInEsc ::= NonInEscChar | Esc
# CharOrNormalEsc ::= NonNormalEscChar | Esc
# Esc ::= "\x" /[0-9a-fA-F][0-9a-fA-F]/
#       | "\u" /[0-9a-fA-F]+/
#       | "\s"    # whitespace
#       | "\b" | "\n" | "\t" | "\r" | "\f" | "\v"
#       | "\." | "\[" | "\\" | "\]" | "\(" | "\)" | "\*" | "\+" | "\?" | "\/"
# NonInEscChar = /[^\[\]\.\\]/
# NonNormalEscChar = /[^\.\*\?\[\]\\]/
#+END_SRC

Basically inputs for the lex generator consist of multiple =NAME = /REGEXP/ {RETAINING}= definitions. The =REGEXP= part is a subset of the one in JavaScript; it supports:

+ basic operators (stars, pluses, and question mark);
+ concat and unions;
+ character sets that supports ranges;
+ greedy vs. non-greedy matching;
+ capturing & non-capturing subgroups;
+ name reference - refer to one regular expression within another;

The =RETAINING= part is for something I called "capture-renaming"; I suppose sometimes you would want to have certain parts within the whole matched string ready for certain specific uses, so I added it in. Basically, you can assign one or many of the capturing subgroups (starting from ID =1=; ID =0= always refer to the whole matched string) to names of your choice, and you can use these names to retrieve those specific subgroups with the generated code. I don't know how many people would need this, but it is a thing you can do now.

When the name of the definition is prefixed with a tilde =~=, that definition is not exported to the generated code, but name refs are still resolved; this is for when you want to reuse regular expressions that shouldn't themselves be the ones that corresponds to tokens.

Currently all input to the generated lexer is treated as if they're encoded in UTF-8.

** Backends

Currently Crimson supports generating code in Nim.

*** Nim

The generated code requires Nim v2.0.0+ and depends on =std/options=, =std/unicode= and =std/tables=.

Two types are exported: one single struct for representing tokens (=Token=) and one enum for different types of tokens (=TokenType=). All the names of the values of =TokenType= are in the format of =TOKEN_{name}=, where ={name}= is the name that specific type of token you've chosen in your input. For example, if we have this input:

#+BEGIN_SRC 
~TEST1 = /a+/ { 0:blah }
TEST2 = /[^c-f]{TEST1}*/
TEST3 = /cde(?:{TEST2})+f/
#+END_SRC

We will have this output (=TEST1= is prefixed with a tilde =~= and is thus not exported here):

#+BEGIN_SRC nim
type
  TokenType* = enum
    TOKEN_TEST2
    TOKEN_TEST3
type
  Token* = ref object
    line*: uint
    col*: uint
    st*: uint
    e*: uint
    ttype*: TokenType
    capture*: TableRef[string,tuple[st: uint, e: uint]]
#+END_SRC

=line= and =col= starts from 0. =capture= are for capture-renaming (explained above).

